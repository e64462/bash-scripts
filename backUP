#!/usr/bin/bash

CONFIGURATION_FILE='/etc/backUP.conf'
MIN_BASH_VER='4.0'
MIN_BORG_VER='1.2.3'
MIN_COREUTIL_VER='7.0'
DATE="$(date +%m-%d-%Y-%I:%M:%S-%p)"
FILENAME=$(basename $0)
IS_NUM_REGEX='^[1-9][0-9]*$'
REPO_STR='This is a Borg Backup repository.'
GETOPT_SHORT='a:e:r:hblcs'
GETOPT_LONG='dest:,repo:,pass,dupe:'
declare -a dupe_paths


usage(){
>&2 cat << EOF
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>

This is free software; you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

This program is used to manage the backup 'database' defined in '$CONFIGURATION_FILE'

It is probably inefficient, buggy, and prone to explode or worse.

Usage: 
 $FILENAME [option] <file>
 
Options:
     -a <path> : Add <path> to the 'database'
     -b        : Backup all 'database' entries with BORG backup
     -c        : Prune and then cleanup BORG backups
 --dupe <path> : Duplicate to <path> ( No limit to number of calls )
     -e        : Extract a BORG backup ( Defaults to ~/temp )
 --dest <path> : Set extraction directory ( Only applies to -e flag )
     -l        : List all BORG backups
     -h        : Display usage information
     -r <path> : Remove <path> from the 'database'
     -s        : Show all paths monitored by $FILENAME
 --pass        : Prompts for the BORG Backup passphrase
 --repo <path> : Sets the BORG repo to <path>

Caveats:
 1) A new -a or -r flag must preceed each path given, something like:
	  $FILENAME -a <path-1> -a <path-2> 

 2) White space in <path> must be escaped or quoted for processing

Configuration options are loaded from '$CONFIGURATION_FILE'

A Borg repository must be setup prior to using '$FILENAME'. Use:
	borg init /path/to/borg/repository

EOF
exit 1
}

parse_config() {
	export BORG_RELOCATED_REPO_ACCESS_IS_OK=yes
	typeset -A config

	config=(
		[BORG_PASSPHRASE]=""
		[BORG_REPO]=""
		[BACKUP_DB]=""
		[SOME_USER]="$SUDO_USER"
		[EXTRACT_TO]=""
	)

	while read line; do
		[[ "$line" =~ ^#.*$ ]] && continue

		if echo $line | grep -F = &>/dev/null; then
			varname=$(echo "$line" | cut -d '=' -f 1)
			value=$(echo "$line" | cut -d '=' -f 2-)
			case "$varname" in
				DUPLICATE_REPO_PATH )
					tval="$(realpath -mq "$value")"
					validate_duplicate "$tval" && dupe_paths+=("$tval")
					;;
				BORG_REPO )
					validate_repo "$value" && config["$varname"]="$value"
					;;
				* )
					config["$varname"]="$value"
					;;
			esac
		fi
		
	done < "$CONFIGURATION_FILE"

	export BORG_PASSPHRASE="${config[BORG_PASSPHRASE]}"
	export BORG_REPO="${config[BORG_REPO]}"
	export BACKUP_DB="${config[BACKUP_DB]}"
	export SOME_USER="${config[SOME_USER]}"
	if [[ -z "${config[EXTRACT_TO]}" ]]; then
		export EXTRACT_TO="$(getent passwd "$SOME_USER" | cut -d: -f6)/temp"
	else
		export EXTRACT_TO="${config[EXTRACT_TO]}"
	fi
}

append_to_backup_list() {
	for argument in "$@"; do 
		if [[ ! -f "$argument" && ! -d "$argument" ]]; then
			echo -e "\nERROR: Path '$argument' doesn't seem to exist. Exiting.\n"
			exit 1
		fi
	done
	echo -en "\n"
	for argument in "$@"; do
		# normalize the input
		file=$(readlink -e "$argument")
		if ! grep -Fxq "$file" $BACKUP_DB; then
			echo "Appending '$file' to end of '$BACKUP_DB'"
			echo "$file" >> $BACKUP_DB
		else
			echo -e "\nWARN: Path '$file' already exists in '$BACKUP_DB'\n"
		fi
	done
	echo -en "\n"
}

remove_from_backup_list() {
	num_lines=$(wc -l $BACKUP_DB | awk '{print $1}')
	
	typeset -A lines_passed

	for argument in "$@"; do
		if [[ $argument =~ $IS_NUM_REGEX && $argument -le $num_lines ]]; then
			# function received a number less than or equal to the number of borg backups
			db_entry=$(sed -n "$argument{p;q}" $BACKUP_DB)
			db_entry_line_num=$argument
		elif grep -Fxq "$argument" $BACKUP_DB; then
			# function received an entry tracked by the database
			db_entry=$argument
			db_entry_line_num=$(grep -nFx "$argument" $BACKUP_DB | cut -f1 -d:)
		else
			# function does not recognize the argument received
			echo -e "\nERROR: No match to '$argument' found in '$BACKUP_DB'\n"
			exit 1
		fi
		lines_passed["$db_entry_line_num"]="$db_entry"
	done
	
	sed_string=""
	echo -en "\n"
	for key in "${!lines_passed[@]}"; do
		echo "Removing '${lines_passed[$key]}' from '$BACKUP_DB'"
		sed_string+="${key}d;"
	done
	echo -en "\n"
	
	sed -i "${sed_string%;}" $BACKUP_DB
}

parse_parents() {
	while read line; do
		printf '%s\n' "$line"
	done < $BACKUP_DB | \

	# The awk command(s) below will create duplicate entries on unsorted data
	sort | \

	# The commands below (recursively?) creates a unique entry for the full *parent* directory structure 
	# pointing to the file/folder we want backed up,
	# Stolen from: https://serverfault.com/questions/877254/tar-does-not-retain-directory-permissions
	awk -F/ '{ d=$1; for (i=2; i <= NF; i++) { print d; d=d "/" $i }; print d }' | \
	awk '{ if (index(old,$0 "/") != 1) { old=$0; print } }' | \
	sed -e '/^[[:space:]]*$/d' -e '/\/$/d'
}

recurse_directories() {
	while read line; do
		if [[ -d $line ]]; then
			# this recursively prints all files and subdirectories of the folder we wish to backup
			find "$line" -print
		fi
	done < $BACKUP_DB
}

create_borg_backup() {
	echo -e "\nCreating new backup '$DATE' in '$BORG_REPO'\n"

	{ parse_parents && recurse_directories; } | sort -u | \
		borg create --paths-from-stdin "$BORG_REPO::$DATE" 2>/dev/null
}

list_borg_backups() {
	printf "\n%-8s%s\n" "#" "ARCHIVE NAME"
	printf "%s%s\n" "------  ------------"
	counter=0
	borg list "$BORG_REPO" 2>/dev/null | \
		while read line; do
			((counter+=1))
			archive_name=$(echo $line | awk '{print $1}')
			if [[ $# -eq 0 ]]; then
				printf "%-8s%s\n" "$counter" "$archive_name"
			elif [[ $counter -eq $1 ]]; then
				printf "%-8s%s\n" "[*$counter]" "$archive_name"
			else
				printf "%-8s%s\n" "$counter" "$archive_name"
			fi
		done 
}

restore_borg_backup() {
	num_archives=$(borg list "$BORG_REPO" 2>/dev/null | wc -l)
	# Don't change permissions of /
	if [[ ! -d "$EXTRACT_TO" ]]; then
		install -d -m 0755 -o "$SOME_USER" -g "$SOME_USER" "$EXTRACT_TO"
		if [[ $? -ne 0 ]]; then 
			# This will probably never be displayed because the function requires root priv.
			echo -e "\nERROR: A problem occurred during extraction."
			echo -e "Try '$FILENAME --dest /path' or check '$EXTRACT_TO'\n"
		fi
	fi

	if [[ $1 =~ $IS_NUM_REGEX && $1 -le $num_archives ]]; then
		# function received a number that is less than or equal to the number of borg backups
		borg_archive=$(borg list "$BORG_REPO" 2>/dev/null | sed -n "$1{p;q}" | awk '{print $1}')
	else	
		borg_archive=$1
	fi

	echo -e "\nExtracting '$borg_archive' to '$EXTRACT_TO'.\n"
	workingdir=$(pwd)
	cd "$EXTRACT_TO"
	borg extract $BORG_REPO::$borg_archive 2>/dev/null
	if [[ $? -ne 0 ]]; then
		echo -e "Borg Backup reports that archive '$1' does not exist in '$BORG_REPO'"
		echo -e "Use '$FILENAME -l' to display a list of all valid archives.\n"
	else
		echo -e "Success! Files extracted to $EXTRACT_TO.\n"
	fi
	cd "$workingdir"
}

borg_compact_and_prune() {
	borg prune --list --keep-daily=7 --keep-weekly=3 --keep-monthly=11 --keep-yearly=1 "$BORG_REPO" 2>/dev/null	
	borg compact "$BORG_REPO" 2>/dev/null
}

duplicate_borg_repo() {
	local primary_repo="$(realpath -mq "$BORG_REPO")/"	# strip excessive trailing slashes

	if [[ ${#dupe_paths[@]} -gt 0 ]]; then
		for secondary_repo in "${dupe_paths[@]}"; do
			rsync -au --delete "$primary_repo" "$secondary_repo"  > /dev/null
		done
	else
		echo -e "\nWARN: No duplication paths specified. '$primary_repo' will not be duplicated\n"
	fi
}

print_database() {
	printf "\n%-8s%-8s%s\n" "#" "TYPE" "PATH"
	printf "%s%s%s\n" "------  ------  ------"
	counter=0
		while read line; do
			if [[ -d $line ]]; then
				entry_type="Folder"
			elif [[ -f $line ]]; then
				entry_type="File"
			fi

			((counter+=1))
			if [[ $# -eq 0 ]]; then
				printf "%-8s%-8s%s\n" "$counter" "$entry_type" "$line"
			elif [[ $counter -eq $1 ]]; then
				printf "%-8s%-8s%s\n" "[*$counter]" "$entry_type" "$line"
			else
				printf "%-8s%-8s%s\n" "$counter" "$entry_type" "$line"
			fi
		done < $BACKUP_DB
}

get_password() {
	read -s -p "Enter Password: " first_entry
	echo
	read -s -p "Re-Enter Password: " second_entry

	if [[ "$first_entry" == "$second_entry" ]]; then
		export BORG_PASSPHRASE="$first_entry"
	else
		echo -e "\nPasswords don't match. Please try again.\n"
		get_password
	fi

	borg info "$BORG_REPO" > /dev/null 2>&1
	if [[ $? -ne 0 ]]; then
		echo -e "\n\nYour password for '$BORG_REPO' is incorrect. Exiting.\n"
		exit 1
	fi
}

validate_repo() {
	if ! [[ -f "${1}/README" && "$(head -n 1 "${1}/README")" == "$REPO_STR" ]]; then
		# according to https://borgbackup.readthedocs.io/en/stable/internals/data-structures.html#repository
		# all BORG repositories contain a "README" file with the string "This is a Borg Backup repository."
		echo -e "\nERROR: The path, '$1' does not contain a valid BORG repository. Exiting.\n"
		exit 2
	else
		return 0
	fi
}

validate_duplicate() {
	# The checks in this function are actually pretty important... duplication is performed with rsync --delete
	# so anything in the destination directory will be wiped out if we're not careful... and this script runs as
	# root, so we don't want to erase all of /!

	local duplicate_repo_path="$1"

	if [[ ! -d "$duplicate_repo_path" ]]; then
		# argument is not a valid directory
		echo -e "\nWARN: Duplication path '$duplicate_repo_path' is not a valid directory and will be skipped.\n"
		return 1
	elif awk '$1 !~ /^#/ && $2 ~ /^[/]/ {print $2}' /etc/fstab | grep -Fxq $duplicate_repo_path; then
        # mountpoint command provided by util-linux - checks if duplicate_repo_path is mounted
        if ! mountpoint -q "$duplicate_repo_path"; then
            echo -e "\nWARN: '$duplicate_repo_path' isn't mounted and will be skipped.\n"
            return 1
        fi
	elif [[ $(ls -A "$duplicate_repo_path" | wc -l) -eq 0 ]]; then
		# empty directories are OK
		return 0
	elif [[ -f "${duplicate_repo_path}/README" && "$(head -n 1 "${duplicate_repo_path}/README")" == "$REPO_STR" ]]; then
		# according to https://borgbackup.readthedocs.io/en/stable/internals/data-structures.html#repository
		# all BORG repositories contain a "README" file with the string "This is a Borg Backup repository."
		return 0
	else
		# duplication directory is probably not a BORG repo, and we don't want to delete everything inside of it
		echo -e "\nWARN: Duplication path '$duplicate_repo_path' is either non-empty or not a BORG repo and will be skipped.\n"
		return 1
	fi
}

{ printf '%s\n%s' "$MIN_BASH_VER" "$BASH_VERSION" | sort -C -V; } > /dev/null 2>&1	
if [[ $? -ne 0 ]]; then
	printf '\n%s\n' "ERROR: $FILENAME depends on coreutils v${MIN_COREUTIL_VER}+ and Bash v${MIN_BASH_VER}+. Your system is configured with"
	printf '%-11s%s\n' "Coreutils:" "$(whoami --version | head -n 1 | awk '{print $NF}')"
	printf '%-11s%s\n\n' "Bash:" "$BASH_VERSION"
	exit 1
fi

getopt --test 
[[ $? -ne 4 ]] && echo -e "\nERROR: $FILENAME depends on enhanced getopt. Please install before continuing\n" && exit 4

borg -V > /dev/null 2>&1
	borg_install_check=$?
{ printf '%s\n%s' "$MIN_BORG_VER" "$(borg -V | awk '{print $NF}')" | sort -C -V; } > /dev/null 2>&1
	borg_version_check=$?

if [[ $borg_install_check -ne 0 || $borg_version_check -ne 0 ]]; then
	printf '\n%s\n' "ERROR: $FILENAME depends on BORG Backup v${MIN_BORG_VER}+. Your system is configured with"
	printf '%-13s%s\n\n' "BORG Backup:" "$(borg -V | awk '{print $NF}')"
	exit 1
fi

args=$(getopt -n "$FILENAME" -a -o "$GETOPT_SHORT" --long "$GETOPT_LONG" -- "$@")
eval set -- ${args}
typeset -A ARGS
while true; do
	if [[ "${1:0:2}" != "--" ]]; then
		ARGS["${1:1:1}"]=true
	else
		if [[ ${#1} -gt 2 ]]; then
			ARGS["${1:2}"]=true
		fi
	fi
	
	case "$1" in
		-b | -c | -l | -h | --pass | -s )
			shift	;;
		-a )
			ADD_ARGS+=("$2")
			shift 2	;;
		--dest )
			DIR_POSITIONAL_ARG="$2"
			shift 2	;;
		--repo )
			REPO_ARG="$2"
			shift 2 ;;
		--dupe )
			tval="$(realpath -mq "$2")"
			validate_duplicate "$tval" && dupe_paths+=("$tval")
			shift 2	;;
		-e )
			EXTC_ARG="${2:=missing}"
			shift 2	;;
		-r )
			REM_ARGS+=("${2%/}")
			shift 2 ;;
		# -- means the end of the arguments; drop this, and break out of the while loop
		-- )
			shift; break ;;
		* ) >&2 echo Unsupported option: $1
			usage ;;
	esac
done

if [[ ${ARGS[h]} || ${#ARGS[*]} -eq 0 ]]; then
	usage
	exit 0
elif [[ $EUID -ne 0 ]]; then
	echo -e "\n$FILENAME requires sudo privileges.\n"
	exit 1
else
	parse_config

	[[ -n ${ARGS[repo]} ]] && REPO_ARG="$(readlink -e "$REPO_ARG")" && \
							validate_repo "$REPO_ARG" && export BORG_REPO="$REPO_ARG"
	[[ -n ${ARGS[pass]} ]] && get_password
	[[ -n ${ARGS[dest]} ]] && export EXTRACT_TO="$DIR_POSITIONAL_ARG"
	[[ -n ${ARGS[r]} ]] && remove_from_backup_list "${REM_ARGS[@]}"
	[[ -n ${ARGS[a]} ]] && append_to_backup_list "${ADD_ARGS[@]}"
	[[ -n ${ARGS[b]} ]] && create_borg_backup
	[[ -n ${ARGS[c]} ]] && borg_compact_and_prune
	[[ -n ${ARGS[e]} ]] && restore_borg_backup "$EXTC_ARG"
	[[ -n ${ARGS[l]} ]] && list_borg_backups
	[[ -n ${ARGS[s]} ]] && print_database

	duplicate_borg_repo
fi

exit 0
